{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","lib/router.js","lib/simpleofflinecache.js","lib/staticcacher.js","lib/sww.js","node_modules/sw-cache-helper/lib/cachehelper.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sww.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var sww = require('./lib/sww.js');\n\nself.ServiceWorkerWare = sww.ServiceWorkerWare;\nself.StaticCacher = sww.StaticCacher;\nself.SimpleOfflineCache = sww.SimpleOfflineCache;\n","'use strict';\n\n// Inspired by expressjs and shed (https://github.com/wibblymat/shed)\nfunction Router(options) {\n  this.options = options;\n  this.stack = [];\n}\n\nRouter.prototype.ALL_METHODS = 'all';\nRouter.prototype.methods = ['get', 'post', 'put', 'delete', 'head',\n  Router.prototype.ALL_METHODS];\n\n/**\n * Add a new route to the stack.\n * @param method (String) http verb to handle the request\n * @param path (Regexp) string or regexp to match urls\n * @param handler (Function) payload to be executed if url matches.\n */\nRouter.prototype.add = function r_add(method, path, handler) {\n  method = method.toLowerCase();\n  if (this.methods.indexOf(method) === -1) {\n    throw new Error('Method %s is not supported', method);\n  }\n  this.stack.push({\n    method: method,\n    path: new RegExp(path),\n    handler: handler\n  });\n};\n\n/**\n * Create the utility methods .get .post ... etc.\n */\nRouter.prototype.methods.forEach(function(method) {\n  Router.prototype[method] = function(path, handler) {\n    return this.add(method, path, handler);\n  };\n});\n\nRouter.prototype.proxyMethods = function r_proxyPrototype(obj) {\n  var self = this;\n  this.methods.forEach(function(method) {\n    obj[method] = function(path, mw) {\n      if (!(typeof mw.onFetch !== 'function' || typeof mw !== 'function')) {\n        throw new Error('This middleware cannot handle fetch request');\n      }\n      var handler = typeof mw.onFetch !== 'undefined' ? mw.onFetch.bind(mw) : mw;\n      self.add(method, path, handler);\n    };\n  });\n};\n\n/**\n * Matches the given url and methods with the routes stored in\n * the stack.\n */\nRouter.prototype.match = function r_match(method, url) {\n  method = method.toLowerCase();\n  var matches = [];\n\n  var self = this;\n  this.stack.forEach(function eachRoute(route) {\n    if (!(method === route.method || route.method === self.ALL_METHODS)) {\n      return;\n    }\n\n    if (route.path.test(url)) {\n      matches.push(route.handler);\n    }\n  });\n\n  return matches;\n};\n\nmodule.exports = Router;\n","'use strict';\n\nvar cacheHelper = require('sw-cache-helper');\n\nvar debug = 0 ? console.log.bind(console, '[SimpleOfflineCache]') : function(){};\n\nfunction SimpleOfflineCache(cacheName) {\n  this.cacheName = cacheName || cacheHelper.defaultCacheName;\n  this.cache = null;\n}\n\nSimpleOfflineCache.prototype.onFetch = function soc_onFetch(request, response) {\n  // If another middleware layer already have a response, the simple cache\n  // just pass through the response and does nothing.\n  if (response !== null) {\n    return Promise.resolve(response);\n  }\n\n  var clone = request.clone();\n  debug('Handing fetch event: %s', clone.url);\n  return this.ensureCache().then(function(cache) {\n    return cache.match(request.clone()).then(function(res) {\n      if (res) {\n        return res;\n      }\n\n      return cacheHelper.fetchAndCache(request, cache);\n    });\n  });\n};\n\nSimpleOfflineCache.prototype.ensureCache = function soc_ensureCache() {\n  if (this.cache) {\n    return Promise.resolve(this.cache);\n  }\n  var self = this;\n  return cacheHelper.getCache(this.cacheName).then(function(cache) {\n    self.cache = cache;\n    return cache;\n  });\n};\n\nmodule.exports = SimpleOfflineCache;\n","'use strict';\n\nvar CacheHelper = require('sw-cache-helper');\n\nfunction StaticCacher(fileList) {\n  if (!Array.isArray(fileList) || fileList.length === 0) {\n    throw new Error('Invalid file list');\n  }\n  this.files = fileList;\n}\n\nStaticCacher.prototype.onInstall = function sc_onInstall() {\n  var self = this;\n  return CacheHelper.getDefaultCache().then(function(cache) {\n    return CacheHelper.addAll(cache, self.files);\n  });\n};\n\nmodule.exports = StaticCacher;\n","/* global fetch, BroadcastChannel, clients */\n'use strict';\n\nvar debug = 1 ? console.log.bind(console, '[ServiceWorkerWare]') : function(){};\nvar StaticCacher = require('./staticcacher.js');\nvar SimpleOfflineCache = require('./simpleofflinecache.js');\nvar Router = require('./router.js');\n\nfunction ServiceWorkerWare() {\n  this.middleware = [];\n  this.router = new Router({});\n  this.router.proxyMethods(this);\n}\n\nServiceWorkerWare.prototype.init = function sww_init() {\n  // lifecycle events\n  addEventListener('install', this);\n  addEventListener('activate', this);\n  addEventListener('beforeevicted', this);\n  addEventListener('evicted', this);\n\n  // network events\n  addEventListener('fetch', this);\n\n  // misc events\n  addEventListener('message', this);\n  // XXX: Add default configuration\n};\n\n/**\n * Handle and forward all events related to SW\n */\nServiceWorkerWare.prototype.handleEvent = function sww_handleEvent(evt) {\n  debug('Event received: %s', evt.type);\n  switch(evt.type) {\n    case 'install':\n      this.onInstall(evt);\n      break;\n    case 'fetch':\n      this.onFetch(evt);\n      break;\n    case 'activate':\n    case 'message':\n    case 'beforeevicted':\n    case 'evicted':\n      this.forwardEvent(evt);\n      break;\n    default:\n      debug('Unhandled event %s', evt.type);\n  }\n};\n\nServiceWorkerWare.prototype.onFetch = function sww_onFetch(evt) {\n  var steps = this.router.match(evt.request.method, evt.request.url);\n  if (steps.length === 0) {\n    // XXX: we should have at least 1 basic middle ware that we install\n    // and can be overwritten. So far ... go to the network :(\n    return fetch(evt.request);\n  }\n  evt.respondWith(steps.reduce(function(prevTaskPromise, currentTask) {\n    debug('Applying middleware %s', currentTask.name);\n    return prevTaskPromise.then(currentTask.bind(currentTask, evt.request.clone()));\n  }, Promise.resolve(null)));\n};\n\n/**\n * Walk all the middle ware installed asking if they have prerequisites\n * (on the way of a promise to be resolved) when installing the SW\n */\nServiceWorkerWare.prototype.onInstall = function sww_oninstall(evt) {\n  var waitingList = [];\n  this.middleware.forEach(function(mw) {\n    if (typeof mw.onInstall !== 'undefined') {\n      waitingList.push(mw.onInstall());\n    }\n  });\n  evt.waitUntil(Promise.all(waitingList));\n};\n\n/**\n * Register a new middleware layer, they will treat the request in\n * the order that this layers have been defined.\n * A middleware layer can behave in the ServiceWorker in two ways:\n *  - Listening to SW lifecycle events (install, activate, message).\n *  - Handle a request.\n * To handle each case (or both) the middleware object should provide\n * the following methods:\n * - on<SW LiveCiclyeEvent>: for listening to SW lifeciclye events\n * - onFetch: for handling fetch urls\n */\nServiceWorkerWare.prototype.use = function sww_use() {\n  // If the first parameter is not a function we will understand that\n  // is the path to handle, and the handler will be the second parameter\n  if (arguments.length === 0) {\n    throw new Error('No arguments given');\n  }\n  var mw = arguments[0];\n  var path = '/';\n  var method = this.router.ALL_METHODS;\n  if (typeof mw === 'string') {\n    path = arguments[0];\n    mw = arguments[1];\n    var kind = typeof mw;\n    if (!mw || !(kind === 'object' || kind === 'function')) {\n      throw new Error('No middleware specified');\n    }\n    if (Router.prototype.methods.indexOf(arguments[2]) !== -1) {\n      method = arguments[2];\n    }\n  }\n\n  this.middleware.push(mw);\n  // Add to the router just if middleware object is able to handle onFetch\n  // or if we have a simple function\n  var handler = null;\n  if (typeof mw.onFetch === 'function') {\n    handler = mw.onFetch.bind(mw);\n  } else if (typeof mw === 'function') {\n    handler = mw;\n  }\n  if (handler) {\n    this.router.add(method, path, handler);\n  }\n  // XXX: Attaching the broadcastMessage to mw that implements onMessage.\n  // We should provide a way to get a reference to the SWW object and do\n  // the broadcast from there\n  if (typeof mw.onMessage === 'function') {\n    mw.broadcastMessage = this.broadcastMessage;\n  }\n};\n\n\n/**\n * Forward the event received to any middleware layer that has a 'on<Event>'\n * handler\n */\nServiceWorkerWare.prototype.forwardEvent = function sww_forwardEvent(evt) {\n  this.middleware.forEach(function(mw) {\n    var handlerName = 'on' + evt.type.replace(/^[a-z]/,\n      function(m){\n         return m.toUpperCase();\n      }\n    );\n    if (typeof mw[handlerName] !== 'undefined') {\n      mw[handlerName].call(mw, evt);\n    }\n  });\n};\n\n/**\n * Broadcast a message to all worker clients\n * @param msg Object the message\n * @param channel String (Used just in Firefox Nightly) using broadcastchannel api to deliver\n * the message, this parameter can be undefined as we listen for a channel undefined in the client.\n */\nServiceWorkerWare.prototype.broadcastMessage = function sww_broadcastMessage(msg, channel) {\n  // XXX: Until https://bugzilla.mozilla.org/show_bug.cgi?id=1130685 is fixed\n  // we can use BroadcastChannel API in Firefox Nightly\n  if (typeof BroadcastChannel === 'function') {\n    var bc = new BroadcastChannel(channel);\n    bc.postMessage(msg);\n    bc.close();\n    return Promise.resolve();\n  } else {\n    // This is suppose to be the way of broadcasting a message, unfortunately it's not working\n    // yet in Chrome Canary\n    return clients.matchAll().then(function(consumers) {\n      consumers.forEach(function(client) {\n        client.postMessage(msg);\n      });\n    });\n  }\n};\n\nmodule.exports = {\n  ServiceWorkerWare: ServiceWorkerWare,\n  StaticCacher: StaticCacher,\n  SimpleOfflineCache: SimpleOfflineCache\n};\n\n","/* global caches, fetch, Promise, Request, module*/\n(function() {\n  'use strict';\n\n  var CacheHelper = {\n    defaultCacheName: 'offline',\n    getCache: function getCache(name) {\n      return caches.open(name);\n    },\n    getDefaultCache: function getDefaultCache() {\n      return this.getCache(this.defaultCacheName);\n    },\n    fetchAndCache: function fetchAndChache(request, cache) {\n      return fetch(request.clone()).then(function(response) {\n        var clone = response.clone();\n        if (parseInt(clone.status) < 400) {\n          cache.put(request.clone(), response.clone());\n        }\n\n        return response.clone();\n      });\n    },\n    addAll: function addAll(cache, urls) {\n      if (!cache) {\n        throw new Error('Need a cache to store things');\n      }\n      // Polyfill until chrome implements it\n      if (typeof cache.addAll !== 'undefined') {\n        return cache.addAll(urls);\n      }\n\n      var promises = [];\n      var self = this;\n      urls.forEach(function(url) {\n        promises.push(self.fetchAndCache(new Request(url), cache));\n      });\n\n      return Promise.all(promises);\n    }\n  };\n\n  module.exports = CacheHelper;\n})();\n"]}